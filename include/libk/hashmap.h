#ifndef _HASHMAP_H_
#define _HASHMAP_H_

#include <libk/heap.h>
#include <stdbool.h>
#include <stddef.h>
#include <stdint.h>

#define DEFAULT_CAPACITY 1
#define LOAD_FACTOR 0.75

// ~Generic~ hashmap data structure. It can store any value or ptr, and be
// keyed by any type that has a hash_<type> function declared.
// The type-specific hashmaps are generated by using the GENERATE_HASHMAP macro.
//
// Requirements for the key:
//   - keys MUST always be heap allocated and must live as long as the map.
//   - there must exist a function: uint32_t key_type_hash(key_type* key)
//   - there must exist a function: bool key_type_equals(key_type* key1, 
//     key_type* key2)  
//
// The macro will generate the new, add, get, remove and delete function, as
// follows
//
// e.g. GENERATE_HASHMAP(string, int) will generate the functions:
//
//      static string_to_int_hashmap* new_string_to_int_hashmap();
//      static void add_string_to_int_hashmap(string_to_int_hashmap* map
//                                            string* key, int value);
//      static bool get_string_to_int_hashmap(string_to_int_hashmap* map,
//                                            string* key, int* output);
//      static bool remove_string_to_int_hashmap(string_to_int_hashmap* map,
//                                               string* key, int* output);
//      static void delete_string_to_int_hashmap(string_to_int_hashmap* map);
//
//     
// Given the verbosity of these functions, there are macros to make life easier
// 
// e.g. string_to_int_hashmap* my_map = new_string_to_int_hashmap();
//      add(my_map, key, value);  - calls push_int_vector
//      get(my_map, key)          - calls pop_int_vector
//      remove(my_map, key)       - calls pop_int_vector
//      delete(my_map)            - calls delete_string_to_int_hashmap
//
// Pointer values can be stored by adding an alias to a pointer type.

// typedef struct hashmap {
//   uint32_t size;
//   uint32_t capacity;
//   size_t key_data_size;
//   size_t value_data_size;
//   void* buckets;
// } vector __attribute__((packed));

// vector* new_hashmap(size_t vector_size, size_t key_data_size,
// 	                size_t value_data_size);
// void delete_hashmap(hashmap* vector);
// void hashmap_resize(hashmap* vector);

// #define add(__hashmap, __key, __value) __vector->add(__hashmap, __key, __value)
// #define get(__hashmap, __key) __vector->get(__hashmap, __key)
// #define remove(__hashmap, __key) __vector->remove(__hashmap, __key)
// #define delete(__hashmap) __hashmap->delete(__hashmap)

// #define GENERATE_HASHMAP(key_type, value_type)                                 \
//   // A single entry in the Hashmap                                             \
//   typedef struct key_type##_to_##value_type##_entry {                          \
//     key_type* key;                                                             \
//     value_type value;                                                          \
//   } key_type##_to_##value_type##_entry                                         \
//                                                                                \
//   // Each bucket in the hashmap will be a vector of entries                    \
//   GENERATE_PTR_VECTOR(key_type##_to_##value_type##_entry);                     \
//                                                                                \
//   typedef struct key_type##_to_##value_type##_hashmap {                        \
//     uint32_t size;                                                             \
//     uint32_t capacity;                                                         \
//     size_t key_data_size;                                                      \
//     size_t value_data_size;                                                    \
//     size_t entry_size;                                                         \
//     key_type##_to_##value_type##_entry_vector* buckets;                        \
//     void (*add) (struct key_type##_to_##value_type##_hashmap* hashmap,         \
//     	           key_type key, value_type value);                              \
//     void (*get) (struct key_type##_to_##value_type##_hashmap* hashmap,         \
//     	           key_type key, value_type* output);                            \
//     type (*remove) (struct key_type##_to_##value_type##_hashmap* hashmap,      \
//     	              key_type key, value_type* output);                         \
//     void (*delete) (struct key_type##_to_##value_type##_hashmap* hashmap);     \
//   } key_type##_to_##value_type##_hashmap __attribute__((packed));              \
//                                                                                \
//   static void add_key_type##_to_##value_type##_hashmap(                        \
//   		struct key_type##_to_##value_type##_hashmap* hashmap, key_type* key,     \
//   	  value_type value) {                                                      \
//     if (hashmap->size > hashmap->capacity * LOAD_FACTOR) {                     \
//       hashmap_resize((hashmap*) hashmap);                                      \
//     }                                                                          \
//                                                                                \
//     // Creates the entry                                                       \
//     key_type##_to_##value_type##_entry* entry = kmalloc(entry_size);           \
//     memset(entry, 0, entry_size);                                              \
//     entry.key = key;                                                           \
//     entry.value = value;                                                       \
//                                                                                \
//     // Grab the vector for this entry should be added to, if it exists         \
//     uint32_t hash = ##key_type##_hash(key);                                    \
//     if (buckets[hash] == NULL) {                                               \
//       buckets[hash] = new_##key_type##_to_##value_type##_entry_vector(false);  \
//     }                                                                          \
//     buckets[hash].add(entry);                                                  \
//     hashmap->size++;                                                           \
//   }                                                                            \
//                                                                                \
//   static void get_key_type##_to_##value_type##_hashmap(                        \ 
//       struct key_type##_to_##value_type##_hashmap* hashmap, key_type* key) {   \
//     // Grab the bucket for this entry                                          \
//     uint32_t hash = ##key_type##_hash(key);                                    \
//     if (buckets[hash] == NULL) {                                               \
//       buckets[hash] = new_##key_type##_to_##value_type##_entry_vector(false);  \
//     }                                                                          \
//     return vect->data[vect->size];                                             \
//   }                                                                            \
//                                                                                \
//   static void delete_##type##_vector(type##_vector* vect) {                    \
//     delete_vector((vector*) vect);                                             \
//   }                                                                            \ 
//                                                                                \
//   static type##_vector* new_##type##_vector() {                                \
//     type##_vector* vector = new_vector(                                        \
//       sizeof(type##_vector), sizeof(type));                                    \
//     vector->delete = delete_##type##_vector;                                   \
//     vector->push = push_##type##_vector;                                       \
//     vector->pop = pop_##type##_vector;                                         \
//     return vector;                                                             \
//   }                                                                            \

#endif  // _HASHMAP_H_